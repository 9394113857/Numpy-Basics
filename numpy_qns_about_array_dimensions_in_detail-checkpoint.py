# -*- coding: utf-8 -*-
"""Numpy Qns About Array Dimensions in detail

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DdtLwcbz6dTY4Q6K_g3JELYlLjKk1mvt

**Purpose of using NumPy:**

1. NumPy is a fundamental package for scientific computing with Python.
2. It provides support for efficient numerical operations on multi-dimensional arrays and matrices.
3. NumPy is used to perform mathematical and logical operations on arrays, manipulate large datasets, and work with linear algebra, Fourier transforms, and more.
4. It's a cornerstone library for data science, machine learning, and scientific research due to its speed and flexibility.
"""



"""**Creating a 3x3 NumPy matrix from a Python list:**"""

import numpy as np

python_list = [1,2,3,4,5,6,7,8,9]
numpy_matrix = np.array(python_list).reshape(3,3)
numpy_matrix

type(numpy_matrix)



"""**Role of numpy.array() in conversion:**

1. The numpy.array() function is used to create a NumPy array from a Python list or tuple.
2. It converts the input data into an array format that supports efficient element-wise operations and other numerical computations.
"""

import numpy as np

python_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9)
python_tuple

numpy_matrix_from_tuple = np.array(python_tuple)

numpy_matrix_from_tuple # without reshape

numpy_matrix.reshape(3,3)

"""1. In this example, the **np.array()** function is used to create a **NumPy array** from the python_tuple.
2. And then the **reshape()** function is used to reshape the array into a **3x3 matrix.**
3. The result will be the same as when you used a list.
"""



"""**reshape() method for creating a 3x3 matrix:**

1. The **reshape()** method in NumPy allows you to change the shape of an array without changing its data.
2. It helps in converting a **1-dimensional** array into a multi-dimensional array like a 3x3 matrix.
3. The method ensures that the total number of elements remains the same before and after reshaping.
"""



"""**Creating a 3x3 NumPy matrix from a different Python list:**"""

import numpy as np

python_list_2 = [9, 8, 7, 6, 5, 4, 3, 2, 1]
numpy_matrix_2 = np.array(python_list_2).reshape(3, 3)

numpy_matrix_2



"""**Creating a 3x3 NumPy matrix with a different number of elements:**

1. **No,** you cannot create a **3x3** matrix from a Python list with a different number of elements.
2. The total number of elements in the **list must match the total number of elements** in the desired matrix shape **(3x3 in this case).**
"""



"""**Code snippet that would give an error due to a different number of elements:**"""

import numpy as np

# Incorrect: Trying to create a 3x3 matrix from a list with 5 elements
# incorrect_list = [1, 2, 3, 4, 5]
# incorrect_matrix = np.array(incorrect_list).reshape(3, 3)

# This will raise a 'ValueError' because the number of elements in the list (5) is not equal to 3x3 (9) elements.



"""**Code snippet that creates a 3x3 matrix as expected:**"""

import numpy as np

# Correct: Creating a 3x3 matrix from a list with 9 elements
correct_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]
correct_matrix = np.array(correct_list).reshape(3, 3)

correct_matrix

"""1. In the first code snippet, attempting to reshape a list with 5 elements into a 3x3 matrix leads to a ValueError because the total number of elements in the list is not compatible with the desired matrix shape.
2. In the second code snippet, we create a 3x3 matrix using a list with 9 elements, which matches the total number of elements required for a 3x3 matrix. The output demonstrates the correctly shaped 3x3 matrix.
"""



"""**Handling mismatched number of elements:**

1. If the number of elements in the Python list does not match the desired matrix size, a **ValueError** will be raised when attempting to reshape.
2. To handle such cases, ensure that the input list has the **correct number of elements** or preprocess the data accordingly.

**Note:**
A 3x3 matrix needs a total of 9 elements to fill all its positions. Given only 5 elements, you won't have enough elements to populate the entire matrix.
"""



"""**Accessing and modifying elements in a NumPy matrix:**

You can access and modify elements in a NumPy matrix using indexing. For example:
"""

element = numpy_matrix[1, 2]  # Accessing element in the second row, third column
numpy_matrix[0, 0] = 99       # Modifying element in the first row, first column

numpy_matrix



"""**Initializing a 3x3 NumPy matrix with zeros or ones:**"""

zeros_matrix = np.zeros((3, 3))
ones_matrix = np.ones((3, 3))

zeros_matrix

ones_matrix



"""**Explanation:**

The output displays the content of the zeros_matrix and ones_matrix arrays. Each matrix is a two-dimensional array because it has rows and columns. In this case, both matrices have a shape of (3, 3), meaning they have 3 rows and 3 columns.

**A.** The zeros_matrix is filled with zeros. Each element in the matrix has a value of 0.0.

**B.** The ones_matrix is filled with ones. Each element in the matrix has a value of 1.0.

Both of these matrices are two-dimensional arrays because they have both rows and columns, forming a grid-like structure.

**Using NumPy for matrices instead of nested Python lists:**

1. NumPy offers significantly improved performance for numerical computations compared to nested Python lists.
2. It provides optimized, contiguous memory storage and efficient element-wise operations.
3. This is crucial when dealing with large datasets and complex calculations, which are common in scientific computing and data analysis.
"""



"""**Certainly! Here are code snippets for creating arrays of different dimensionalities with added comments for clarification:**"""

import numpy as np

# Creating a 1D array (vector)
one_dim_array = np.array([1, 2, 3, 4, 5])
one_dim_array

import numpy as np

# Creating a 2D array (matrix) with 3 rows and 4 columns
two_dim_array = np.array([[1, 2, 3, 4],
                          [5, 6, 7, 8],
                          [9, 10, 11, 12]])
two_dim_array

import numpy as np

# Creating a 3D array with 2 "layers", 3 rows, and 4 columns
three_dim_array = np.array([[[1, 2, 3, 4],
                             [5, 6, 7, 8],
                             [9, 10, 11, 12]],

                            [[13, 14, 15, 16],
                             [17, 18, 19, 20],
                             [21, 22, 23, 24]]])
three_dim_array

import numpy as np

# Creating an N-dimensional array (hypothetical example)
n_dim_array = np.array([[[[1, 2], [3, 4]],
                         [[5, 6], [7, 8]]],

                        [[[9, 10], [11, 12]],
                         [[13, 14], [15, 16]]]])
n_dim_array

"""In each of these examples, the number of indices required to access an element within the array corresponds to its dimensionality. Remember, the dimensionality is not solely determined by the number of rows or columns, but rather by the number of indices needed to pinpoint an element within the array."""



"""The dimensionality of an array refers to the number of indices required to access an element within that array. It's not directly related to the number of rows or columns. Here's a breakdown:

**1-Dimensional Array:** Requires 1 index to access an element. It's like a list or a vector.

**2-Dimensional Array:** Requires 2 indices to access an element, typically representing rows and columns. It's like a table.

**3-Dimensional Array:** Requires 3 indices to access an element, often used for data with three dimensions like volume data.

**N-Dimensional Array:** Requires N indices to access an element. These are used for data with more complex structures.

**Note:** The number of rows or columns in a 2D array does not directly dictate its dimensionality. For example, a 2D array with 5 rows and 3 columns is still a 2-dimensional array because it requires two indices (row and column) to access an element.

**1. Number of Indices Needed:** When we talk about the "dimensionality" of an array, we're referring to how many indices (or subscripts) are required to specify a particular element within the array.

**2. Pinpointing an Element:** For example, consider a 2D array as a table with rows and columns. To access an element in this array, you need two pieces of information: the row index and the column index. This is why it's called a 2-dimensional array, as it requires 2 indices to pinpoint a specific element.

**3. Not Solely Determined by Rows or Columns:** The dimensionality of an array is not determined solely by the number of rows or columns. Instead, it's determined by the number of indices required to access an element. Even if you have an array with many rows and columns, it can still be 2-dimensional if it requires only two indices.

**4. For example, consider a 5x5 array.** If you need two indices (row and column) to access an element within this array, it's still a 2-dimensional array. The size of each dimension (rows, columns, etc.) doesn't dictate the array's dimensionality; rather, it's the number of indices you need to use to locate an element.

**Overview:**
In summary, the "dimensionality" of an array refers to the number of indices needed to specify an element's position within that array, and this concept is not directly tied to the number of rows or columns in the array.
"""



"""**Absolutely, here are code snippets for different 2D, 3D, and 4D arrays with comments to help you understand how indices work:**"""

# 2-Dimensional Array:
import numpy as np

# Creating a 2D array with 3 rows and 4 columns
two_dim_array = np.array([[1, 2, 3, 4],
                          [5, 6, 7, 8],
                          [9, 10, 11, 12]])

# Accessing elements using indices
element_row = 1
element_column = 2
value = two_dim_array[element_row, element_column]  # Accessing the element at row 1, column 2
print("Value at (1, 2):", value)

two_dim_array

# 3-Dimensional Array:
import numpy as np

# Creating a 3D array with 2 "layers", 3 rows, and 4 columns
three_dim_array = np.array([[[1, 2, 3, 4],
                             [5, 6, 7, 8],
                             [9, 10, 11, 12]],

                            [[13, 14, 15, 16],
                             [17, 18, 19, 20],
                             [21, 22, 23, 24]]])

# Accessing elements using indices
layer = 0
row = 1
column = 3
value = three_dim_array[layer, row, column]  # Accessing the element at layer 0, row 1, column 3
print("Value at (0, 1, 3):", value)

three_dim_array

# 4-Dimensional Array:
import numpy as np

# Creating a 4D array with 2 "sets", each having 2 "layers", 3 rows, and 4 columns
four_dim_array = np.array([[[[1, 2, 3, 4],
                             [5, 6, 7, 8],
                             [9, 10, 11, 12]],

                            [[13, 14, 15, 16],
                             [17, 18, 19, 20],
                             [21, 22, 23, 24]]],

                           [[[25, 26, 27, 28],
                             [29, 30, 31, 32],
                             [33, 34, 35, 36]],

                            [[37, 38, 39, 40],
                             [41, 42, 43, 44],
                             [45, 46, 47, 48]]]])

# Accessing elements using indices
set_index = 1
layer_index = 0
row_index = 2
column_index = 1
value = four_dim_array[set_index, layer_index, row_index, column_index]  # Accessing the element in set 1, layer 0, row 2, column 1
print("Value at (1, 0, 2, 1):", value)

four_dim_array



"""1. In these examples, the **indices correspond to the dimensions of the arrays.**

2. The comments within the code snippets indicate **which index is used for each dimension** when accessing a specific element.

3. This should help you understand how **indices work in different-dimensional arrays.**
"""

